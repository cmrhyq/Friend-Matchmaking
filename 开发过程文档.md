# 开发过程文档



## 2024-12-18

### 任务

- 整合knife4j + swagger接口文档 √

- 抓取yupi知识星球的自我介绍数据 √



### 过程要点

1. 实现了knife4j + swagger接口文档

   1. knife4j 和 swagger 这两个东西有点坑的一点是在使用时要注意他俩和 spring boot 的版本要对应，不然启动不了，具体可以参考官方文档

   2. spring boot的版本大于 2.6时要加上如下配置

      ```yaml
        mvc:
          pathmatch:
            matching-strategy: ant_path_matcher
      ```
   3. 如果是线上对外版本，首先得关闭这个功能
   4. 可以通过增加注解，比如在controller上增加@ApiOperation注解来补充信息
   5. 通过@Profile({"test", "dev"})注解来实现当前在哪个环境才加载swagger

2. 鱼皮的spring_boot_init项目初始化模板中的数据库字段是用的驼峰命名法，对数据库兼容性不高

3. 鱼皮知识星球自我介绍接口地址：`https://api.zsxq.com/v2/hashtags/48844541281228/topics?count=20&end_time=2024-07-15T11%3A26%3A12.836%2B0800`

   1. 参数end_time是可选项，值为 `2024-07-15T11:26:12.836+0800`

4. 鱼皮视频里选择了通过easyexcel读取知识星球后台的数据表格，我选择了使用AI造假数据

   1. 使用了ReadListener，读取监听器。具体可以看easyexcel官网




## 2024-12-19

### 任务

- 搜索页面功能开发



### 过程要点

1. 前端页面跳转传值
   1. vue-router的router.query传值，query的传值方法就相当于前端请求后端的get请求的传值方式，也就是浏览器地址栏的接口的问号后面的东西，例`https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1`
   2. vuex（全局状态管理），搜索页关键词存到状态中，搜索页从状态中取值，同样的，应该还可以用session和其他的缓存
2. 搜索页面的搜索按钮和取消按钮（取消按钮不存在了）的存放地方感觉还是不合理，如果搜索按钮放最下面的话感觉又不合适
3. 前端的搜索结果页面请求后端的时候发现一个问题，当传递给后台的参数格式为：`?ids=1&ids=2&ids=3`这种的时候，请求时会出现错误，后台接收到的参数值是`?ids[]=1&ids[]=2&ids[]=3`这样的，所以要用到 [paramsSerializer](https://blog.csdn.net/weixin_43970434/article/details/121402694)序列化



## 2024-12-23

### 任务

- 用户页面功能开发



### 过程要点

1. [session存储共享（分布式登录）](https://blog.csdn.net/xushuai2333333/article/details/126946816)

   1. Redis（基于内存的K\V数据库），选择原因是因为用户信息 / 登录信息的判断很频繁，Redis基于内存，存取速度快，读写性能高，单机 QPS 大概在 5W~10W

   2. 可以使用spring-session-data-redis库，一个实现session共享的库

      ```yml
      spring:
        # session 配置
        session:
          # 取消注释开启分布式 session（须先配置 Redis）
          store-type: redis
          # 30 天过期
          timeout: 2592000
      ```
      
      

## 2024-12-24

### 任务

- 用户个人信息页面，登录页面开发和接口联调




### 过程要点

1. 在调试前端和登录和获取用户信息时，发现**登录以后**调用获取当前登录的用户信息时提示未登录的情况
   1. 出现这种情况的具体表现：使用 **Spring Session** + redis 实现的会话管理
   2. 原因：前端没有携带cookie，导致请求到后端，后端不认识你是谁
   3. 排查要点如下
      - 确保session配置正确：检查session使用的数据存储方式
      - 确保session cookie配置正确：检查springboot的session和cookie的配置、检查跨域的配置
      - 确保前端请求的cookie设置：检查请求时是否携带了会话cookie，比如使用axios的话是否配置了`withCredentials = true`
      - 检查 Spring Security 配置，确保认证过程与会话管理正常工作。
      - 检查 Redis 存储或其他会话存储后端的配置，确保会话信息持久化且不会丢失。



## 2024-12-25

### 任务

- 用户修改页面功能开发



### 过程要点

1. 通过缓存来存储用户信息，然后弃用了，原因是我发现使用了缓存以后会导致用户更新个人信息后返回个人信息页面时个人信息显示的是旧数据



## 2024-12-27

### 任务

- 主页页面功能开发
- 系统用户数据mock
- 并发编程，并发mock数据



### 过程要点

1. 使用faker包mock数据时在当前的springboot中引入了faker的依赖会出现`Correct the classpath of your application so that it contains compatible versions of the classesorg.springframework.boot.env.OriginTrackedYamlLoader and org.yaml.snakeyaml.LoaderOptions`的问题，删除了faker的依赖就没了
   1. 然后通过spring自带的scheduling+mybatis plus批量插入数据，可以快速的mock数据到数据库，只不过暂时没解决mock的数据都很像的问题。
2. 并发编程要注意执行的先后顺序，不要用到非并发类的集合（用线程不安全的集合，会出奇奇怪怪的问题）



## 2025-1-8

### 任务

- 完成SseEmitter功能开发



### 过程要点

1. SEE （Server-sent events) 是一种通过http推送消息连接技术。 前端通过 web api EventSource 来跟后端建立连接。 后端可以通过这个连接发送任意的字符串数据。 SEE 的 MIME 请求类型 是text/event-stream
2. SSE 比较适适合做通知类型的需求。类似订单通知。更新通知，感觉不适合用来做聊天室，然后前端的功能好像没实现完，看不到发送的消息



## 2025-1-9

### 任务

- 并发编程，并发mock数据



### 过程要点

1. 并发编程时，任务的耗时会被各种不同的因素影响，比如说机器的性能，数据传输的性能，线程池的配置

2. cpu密集型：`CPU密集型`，也叫`计算密集型`，一般是指服务器的硬盘、内存硬件性能相对CPU好很多，或者使用率低很多。系统运行CPU读写I/O(硬盘/内存)时可以在很短的时间内完成，几乎没有阻塞（等待I/O的实时间）时间，而CPU一直有大量运算要处理，因此CPU负载长期过高。

   1. CPU密集几乎无I/O阻塞，CPU一直会全速运行。`如果是单核情况下，开多线程是没有意义的`，说白了就是一个CPU来回切着运行而已，徒增线程切换的资源消耗，卵用没有。可见，CPU密集任务只有在`多核CPU上`、`开多线程`才可能提速。

   2. CPU使用率较高时（如我们训练算法模型、搞训练集），通常线程数只需要设置为CPU核心数的线程个数就可以了。单CPU对应单线程效率最高。

   3. > 一般其计算公式可遵循：**CPU密集型核心线程数 = CPU核数**。

3. IO密集型：`I/O密集型`相反，一般是指服务器CPU的性能相对硬盘、内存硬件好很多，或者使用率低很多。系统运行多是CPU在等I/O (硬盘/内存) 的读写操作，此类情景下CPU负载并不高。

   1. I/O密集型的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I/O操作，而程序的逻辑做得并不好，没有充分利用CPU能力，导致`线程空余时间很多`。通常我们会开`CPU核心数`数倍的线程，在线程进行 I/O 操作 CPU 空闲时，启用其他线程继续使用 CPU，以提高 CPU 的使用率，充分利用CPU资源。

   2. > 一般其计算公式可遵循：**I/O密集型核心线程数 = CPU核数 / （1-阻塞系数）**。

4. **I/O密集型**：`当线程等待时间所占比例越高，需要越多线程`，启用其他线程继续使用CPU，以此提高CPU的利用率；

5. **CPU密集型**：`当线程CPU时间所占比例越高，需要越少的线程`。任务越多，花在进程、线程切换的时间就越多，通常线程数和CPU核数一致即可，这一类型在开发中主要出现在一些计算业务频繁的逻辑中。



## 2025-1-13

### 任务

- 首页数据预加载缓存



### 过程要点

1. 首页数据预加载缓存是为了解决首页加载慢的问题，从而达到首页秒开。
   1. 既然要缓存数据，那么最好就用定时任务，在一个系统流量少的时间点去执行，并且得用到分布式锁：控制同一时间只有一台机器去执行定时任务
2. 分布式锁
   1. 在多线程环境中，如果多个线程同时访问共享资源（例如商品库存、外卖订单），会发生数据竞争，可能会导致出现脏数据或者系统问题，威胁到程序的正常运行。
   2. 为了保证共享资源被安全地访问，我们需要使用互斥操作对共享资源进行保护，即同一时刻只允许一个线程访问共享资源，其他线程需要等待当前线程释放后才能访问。这样可以避免数据竞争和脏数据问题，保证程序的正确性和稳定性。
3. **当你感觉你的某个接口比较慢**
   1. 首先可以把接口改成并发执行
   2. 找到比较慢的环节，找到以后看能否优化
4. 缓存的实现
   1. Redis：分布式缓存
   2. Memcached：分布式缓存
   3. Etcd：云原生架构的一个分布式存储，适合存储配置，扩容能力强
   4. Ehcache：单机
   5. 本地缓存：Java内存Map
   6. Caffeine： Java 内存缓存，高性能
   7. Google Guava
5. Redis
   1. key - value存储系统
   2. Redis在Java中的实现方式
      1. Spring Data Redis
      2. Jedis
      3. Redisson
   3. Redis数据结构
      1. String 字符串：”alan”
      2. List 列表：['ab','bc']
      3. Set 集合：['ab','bc'] 值不可重复
      4. Hash 哈希：{"name":"a", "age": 12}
      5. Zset 集合：{ alan - 9， yupi - 7} （比set多了一个分数，适合做排行榜）
6. **在向Redis中插入数据后，查看数据时发现是乱码**
   1. 可以考虑是不是RedisTemplate的默认的序列化的问题
   2. RedisTemplate默认的序列化是jdk的序列化
   3. 解决方法就是自已定义一个RedisTemplate，然后指定一下序列化
7. Redis缓存Key设计
   1. 实际开发中，为了节省成本，很多项目都是用的同一个redis，所以得在缓存key前面加前缀
   2. 比如说：系统id:模块id:功能id:用户id
   3. **Redis的key一定要设置过期时间**



## 2025-1-13

### 任务

- 首页数据预加载缓存



### 过程要点

1. 缓存预热

   意义

   - 每天新增少，总用户多

   优点

   - 能解决第一个用户访问时很慢的问题，也能一定程度上保护数据库，可以让用户始终保持很快
   
   缺点

   - 增加开发成本，需要额外的开发设计工作
   - 预热的时机和时间错了，有可能缓存的数据就不对或者太老
   - 需要占用额外空间
   
   如何预热
   
   - 定时
   - 模拟触发（手动触发）



## 2025-1-20

### 任务

- 首页数据预加载缓存



### 过程要点

1. 通过定时任务的方式实现首页数据预加载缓存

   Java操作Redis框架

   - Spring Data Redis：Spring自带的Redis操作框架
   - Jedis：独立于Spring的Redis操作的Java客户端，一定要配合Jedis Pool使用
   - Lettuce：高阶的操作Redis的Java客户端
   - Redisson：分布式操作Redis的Java客户端，能让你像操作本地集合一样操作redis

   框架对比：

   - 如果**没有过多的定制化要求**，而且**用的是Spring**，可以用**Spring Data Redis**
   - 如果使用的**不是Spring**，并且**追求简单**，**没用过高的性能要求**，就用**Jedis + Jedis Pool**
   - 如果项目**不是Spring**，并且**要求高性能**、**高定制化**，就用**Lettuce**，支持异步、连接池
   - 如果你的**项目是分布式**，需**要用到一些分布式的特性（分布式锁、分布式集合**），推荐**Redisson**
   
2. 首页的缓存数据放到redis中时的key名不要加id，不然只能一个用户用，如果要分析这个用户的行为来做个性化推荐那就可以加上用户的id



## 2025-2-12 ~ 2-16

### 任务

- 首页数据预加载缓存 - 分布式锁



### 过程要点

1. 为什么要用分布式锁控制定时任务的执行
   - 不控制的话，如果这些服务部署到多个服务器上的话，那就会出现脏数据
   - 其二就是比较浪费资源
   
2. 怎么解决呢
   - 分离定时任务和主程序：只在一个服务器运行定时任务。缺点成本大
   
   - 写死配置：每个服务器都执行定时任务，但是只有指定的（代码中配置好的）服务器才执行真实的定时任务逻辑，其他的直接返回。缺点配置不太灵活，并且ip可能是不固定的。
   
   - 动态配置：配置可以轻松方便的更新，并且只有指定的（代码中配置好的）服务器才执行真实的定时任务逻辑，缺点是需要人工修改，并且服务器多了，ip不可控很麻烦
     - 数据库
     - Redis
     - 配置中心（Nacos，Apollo）
     
   - 使用定时任务中间件：XxlJob
   
   - **使用分布式锁**：
     
     分析
     
     - 抢占资源，只有抢到锁的服务器才能执行业务逻辑，可以不用手动配置，多少个服务器都一样，缺点是增加成本。
     
     - 有限资源情况下，控制同一时间段，只有某些线程（用户/服务器）能访问资源
     - 单个锁会出现只对单个JVM有效，无法控制其他的JVM，所以就要使用分布式锁
     
     实现机制
     
     - 分布式环境下，如何保证只有一个服务器能抢到锁 ，核心思想就是先来的把数据改成自己的标识，后来的发现标识已存在，就抢锁失败，继续等待
     - 使用mysql的行级锁：select for update
     - **Redis 存标识**：常用，因为读写速度快，支持setnx（如果不存在才设置，否则返回false）
       - 使用Redisson：它是一个java操作Redis的客户端，提供了大量的分布式数据集来简化对Redis的操作
     - Zookeeper实现：不推荐
     
     注意
     
     - 用完了锁一定要释放
     - 锁一定要加过期时间，因为释放锁也有可能失败
     - 方法执行时间过长，可能导致锁已经释放，但是方法还在执行，或者给当前在执行的方法续期（比如说执行前判断是否还在执行，还在执行就续期）
     - 方法执行时间过长，还可能导致连锁效应（a抢到了锁，但是a最后执行超时了，超时了锁自动释放了，b抢到锁进来了以后，a又出去了，释放了b的锁），解决问题就需要在释放锁之前判断是不是自己的锁
     - 在判断成功了当前的锁是自己的锁之后，准备去释放时，刚好锁自动过期了并且下一个任务已经上锁了，这个时候去释放锁就还是释放了别人的锁。解决方法就是在判断和释放锁之间需要保证操作的原子性，就是在这之间不准任何的插入操作，最好通过Redis+Lua实现

3. Redisson分布式锁要点

   - 在给任务加锁时要注意waitTime要设置成0，表示立即获取锁，志强一次，抢不到就返回false

     ```java
     // tryLock方法参数：waitTime 等待时间, leaseTime 锁过期时间, 单位: 毫秒
     if (lock.tryLock(0, 30000L, TimeUnit.MILLISECONDS)){}
     ```

     
